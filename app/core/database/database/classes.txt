<?php
/**
 * Namespace para a classe DBConnection
 */
namespace core\database;

use PDOException;
use RuntimeException;


/**
 * Classe DBConnection para estabelecer uma conexão com o banco de dados.
 */

class DBConnection {
    
    /**
     * Propriedade para armazenar a conexão PDO.
     *
     * @var \PDO
     */
    private $conn;
    
    /**
     * Construtor da classe DBConnection.
     *
     * @throws \InvalidArgumentException se a configuração do banco de dados estiver incompleta.
     * @throws \RuntimeException se a conexão com o banco de dados falhar.
     */
    function __construct() {
        if (session_status() == PHP_SESSION_NONE) {
            session_start();
        }
        if (!isset( $_SESSION['database']['host'], $_SESSION['database']['user'], $_SESSION['database']['pass'], $_SESSION['database']['schema'])) {
            throw new \InvalidArgumentException("Configuração de banco de dados incompleta.");
        }
        
        try {
            $dsn = "mysql:host={$_SESSION['database']['host']};dbname={$_SESSION['database']['schema']}";
            $this->conn = new \PDO($dsn, $_SESSION['database']['user'], $_SESSION['database']['pass']);
            $this->conn->setAttribute(\PDO::ATTR_ERRMODE, \PDO::ERRMODE_EXCEPTION);
        } catch( PDOException $e) {
            throw new RuntimeException("Connection failed: " . $e->getMessage());
        }
    }
    
    /**
     * Função para realizar uma query SQL no banco de dados.
     *
     * @param string $sqlCommand Comando SQL para ser executado.
     * 
     * @throws \RuntimeException se a query falhar.
     * 
     * @return array Retornará os resultados da query.
     */
    public function query($sqlCommand) {
        try {
            $stmt = $this->conn->query($sqlCommand);
            return $stmt->fetchAll(\PDO::FETCH_ASSOC);
        } catch (\PDOException $error) {
            throw new \RuntimeException("Erro: " . $this->getErroMensage("mysql",$error->getCode()) . "\n". $error->getMessage());
        }
    }
    
    public function prepareQuery($sqlCommand, $values) {
        try {
            $stmt = $this->conn->prepare($sqlCommand);
            $stmt->execute($values);
            return $stmt->fetchAll(\PDO::FETCH_ASSOC);
        } catch (\PDOException $error) {
            throw new \RuntimeException("Erro: " . $this->getErroMensage("mysql",$error->getCode()) . "\n". $error->getMessage());
        }
    }
    
    public function getErroMensage($sgbd, $errorNumber) {
        if (session_status() == PHP_SESSION_NONE) {
            session_start();
        }
        global $mensagensDeErro;
        require $_SESSION['path']['pdoErrors'];
        return ( $mensagensDeErro[$sgbd][$errorNumber] );
    }
    
    function getConn() {
        return ($this->conn);
    }
}

?>
<?php

namespace app\core\database;

use ReflectionClass;
use Exception;
use core\utils\Sanitize;
use core\database\DBQuery;

/**
 * Classe DBQueryFromAnnotations
 *
 * Esta classe estende a classe DBQuery e permite a definição das informações da tabela através de anotações.
 *
 * @package app\core\database
 */
class DBQueryFromAnnotations extends DBQuery {
    
    private $schemaName  = "";
    private $tableName  = "";
    private $fieldsName = [];
    private $primaryKeys = [];
    private $uniqueKeys = [];
    private $foreignKeys = [];
    private $notNullFields = [];
    
    
    /**
     * Construtor da classe DBQueryFromAnnotations
     *
     * @param object $object O objeto com as anotações
     * @throws Exception Se ocorrer um erro ao analisar as anotações
     */
    public function __construct($object) {
        
        parent::__construct('', '', '');
        
        $reflector = new ReflectionClass(get_class($object));
        $properties = $reflector->getProperties();
        

        global $matches;
        
        foreach ($properties as $property) {
            $doc = $property->getDocComment();
            $matches = null;
            if (preg_match('/@DBSchema\((.*?)\)/', $doc, $matches)) {
                $this->schemaName = $matches[1][0];
            }
            if (preg_match('/@DBTable\((.*?)\)/', $doc, $matches)) {
                $this->tableName = $matches[1][0];
            }
            
            if (preg_match('/@DBField\((.*?)\)/', $doc, $matches)) {
                $fieldParts = explode(", ", $matches[1]);
                $fieldNameInDB = trim($fieldParts[0], '"');
                $fieldNameInClass = isset($fieldParts[1]) ? trim($fieldParts[1], '"') : $fieldNameInDB;
                
                if ($property->getName() === $fieldNameInClass) {
                    $this->fieldsName[] = $fieldNameInDB;
                } else {
                    throw new Exception("Annotation @DBField does not match property name for " . $property->getName());
                }
                
                if (preg_match('/@DBPrimaryKey/', $doc)) {
                    $this->primaryKeys[] = $fieldNameInDB;
                }
                
                if (preg_match('/@DBNotNull/', $doc)) {
                    $this->notNullFields[] = $fieldNameInDB;
                }
                
                if (preg_match('/@DBUniqueKey/', $doc)) {
                    $this->uniqueKeys[] = $fieldNameInDB;
                }
                
                if (preg_match('/@DBForeignKey\((.*?)\)/', $doc, $matches)) {
                    $foreignKeyParts = explode(", ", $matches[1]);
                    $column = trim($foreignKeyParts[0], '"');
                    $refTable = trim($foreignKeyParts[1], '"');
                    $refColumn = trim($foreignKeyParts[2], '"');
                    $this->foreignKeys[] = [
                        "column" => $column,
                        "refTable" => $refTable,
                        "refColumn" => $refColumn
                    ];
                }
            }
        }
        
        $fieldsNameStr = implode(", ", $this->fieldsName);
        $primaryKeyStr = (count($this->primaryKeys) === 1) ?$this->primaryKeys[0] : $this->primaryKeys;
        
        parent::__construct($this->tableName, $this->fieldsNameStr, $this->primaryKeyStr);
        parent::addForeignKeys($this->foreignKeys);
        parent::addUniqueKeys($this->uniqueKeys);
    }
    
    /**
     * Insere os valores validados na tabela.
     *
     * @param array $values Os valores a serem inseridos
     * @return bool Retorna true se a inserção for bem-sucedida, caso contrário, lança uma exceção
     * @throws // InvalidArgumentException Se o número de valores informados não for equivalente aos campos da tabela
     * @throws Exception Se houver violação de chave única ou estrangeira, ou qualquer outra exceção do PDO
     */
    public function insertValidated($values) {
        $values = (new Sanitize(false, false, true))->toClean($values);
        
        if (count($values) !== count($this->fieldsName)) {
            throw new \InvalidArgumentException("O número de valores informados não é equivalente aos campos da tabela!");
        }
        
        // Verificar campos de chave única
        foreach ($this->uniqueKeys as $fieldName) {
            $uniqueCheckQuery = "SELECT COUNT(*) FROM {$this->tableName} WHERE {$fieldName} = ?";
            $uniqueCheckStatement = $this->conn->prepare($uniqueCheckQuery);
            $uniqueCheckStatement->execute([$values[$fieldName]]);
            $count = $uniqueCheckStatement->fetchColumn();
            if ($count > 0) {
                throw new Exception("O valor '{$values[$fieldName]}' para o campo '{$fieldName}' já existe na tabela!");
            }
        }
        
        // Verificar campos não nulos
        foreach ($this->notNullFields as $fieldName) {
            if (!isset($values[$fieldName]) || $values[$fieldName] === '') {
                throw new Exception("O valor para o campo '{$fieldName}' não pode ser nulo!");
            }
        }
        
        // Verificar campos de chave estrangeira
        /*
        foreach ($this->foreignKeys as $foreignKey) {
            $foreignTable = $foreignKey['refTable'];
            $foreignColumn = $foreignKey['refColumn'];
            $foreignValue = $values[$foreignKey['column']];
            $foreignCheckQuery = "SELECT COUNT(*) FROM {$foreignTable} WHERE {$foreignColumn} = ?";
            $foreignCheckStatement = $this->conn->prepare($foreignCheckQuery);
            $foreignCheckStatement->execute([$foreignValue]);
            $count = $foreignCheckStatement->fetchColumn();
            if ($count === 0) {
                throw new Exception("O valor '{$foreignValue}' para o campo '{$foreignKey['column']}' não existe na tabela de referência '{$foreignTable}'!");
            }
        }
        */
        $sql = "INSERT INTO {$this->tableName} (" . implode(', ', $this->fieldsName) . ")";
        $sql .= " VALUES ('" . implode("', '", $values) . "')";
        
        try {
            return $this->conn->query($sql);
        } catch (\PDOException $error) {
            if ($error->getCode() == 23000) {
                throw new Exception('Violação de chave única ou estrangeira.');
            }
            throw $error;
        }
    }
    

	public function getSchemaName(){
		return $this->schemaName;
	}

	public function setSchemaName($schemaName){
		$this->schemaName = $schemaName;
		return $this;
	}

	public function getTableName(){
		return $this->tableName;
	}

	public function setTableName($tableName){
		$this->tableName = $tableName;
		return $this;
	}

	public function getFieldsName(){
		return $this->fieldsName;
	}

	public function setFieldsName($fieldsName){
		$this->fieldsName = $fieldsName;
		return $this;
	}

	public function getPrimaryKeys(){
		return $this->primaryKeys;
	}

	public function setPrimaryKeys($primaryKeys){
		$this->primaryKeys = $primaryKeys;
		return $this;
	}

	public function getUniqueKeys(){
		return $this->uniqueKeys;
	}

	public function setUniqueKeys($uniqueKeys){
		$this->uniqueKeys = $uniqueKeys;
		return $this;
	}

	public function getForeignKeys(){
		return $this->foreignKeys;
	}

	public function setForeignKeys($foreignKeys){
		$this->foreignKeys = $foreignKeys;
		return $this;
	}

	public function getNotNullFields(){
		return $this->notNullFields;
	}

	public function setNotNullFields($notNullFields){
		$this->notNullFields = $notNullFields;
		return $this;
	}
	
/**
	 * A classe DBQueryFromAnnotations é definida e estende a classe DBQuery.
	 * O construtor da classe DBQueryFromAnnotations recebe um parâmetro $object que representa o objeto com as anotações.
	 *
	 * É criada uma instância da classe ReflectionClass para obter informações sobre a classe do objeto passado como parâmetro.
	 * É inicializada uma variável $properties que armazenará as propriedades da classe.
	 * A chamada ao construtor da classe pai (DBQuery) é feita com os parâmetros vazios, pois eles serão definidos posteriormente.
	 * A variável $matches é declarada globalmente para ser usada posteriormente.
	 * São declaradas variáveis para armazenar o nome da tabela, os nomes dos campos, as chaves primárias, as chaves únicas e as chaves estrangeiras.
	 * Utilizou-se expressão regular para buscar a anotação @DBField no comentário. Se a anotação for encontrada, o código dentro do if é executado.
	 * A anotação @DBField é composta por dois parâmetros separados por vírgula: o nome do campo no banco de dados e o nome do atributo na classe. Esses parâmetros são extraídos e armazenados nas variáveis $fieldNameInDB e $fieldNameInClass, respectivamente.
	 * É feita uma verificação se o nome da propriedade na classe corresponde ao nome especificado na anotação. Se a verificação falhar indica que a anotação não corresponde ao nome da propriedade.
	 * O nome do campo no banco de dados é adicionado ao array $fieldsName.
	 * É feita uma verificação para buscar a anotação @DBPrimaryKey. Se a anotação for encontrada, o nome do campo no banco de dados é adicionado ao array $primaryKeys.
	 * É feita uma verificação para buscar a anotação @DBForeignKey. Se a anotação for encontrada, os parâmetros da anotação são extraídos e armazenados nas variáveis $localField, $referenceTable e $referenceField. Esses valores são adicionados ao array $foreignKeys como um array associativo contendo as informações da chave estrangeira.
	 * É feita uma verificação para buscar a anotação @DBUniqueKey. Se a anotação for encontrada, o nome do campo no banco de dados é adicionado ao array $uniqueKeys.
	 * Após percorrer todas os atributos da classe, os nomes dos campos são transformados em uma string separada por vírgulas e armazenados na variável $fieldsNameStr
	 * A variável $primaryKeyStr é definida com base na quantidade de chaves primárias. Se houver apenas uma chave primária, o valor é o próprio nome do atributo. Caso contrário, o valor é o array de chaves primárias.
	 * O construtor da classe ancestral DBQuery é chamado com as informações coletadas, definindo o nome da tabela, os nomes dos campos e as chaves primárias.
	 * Os métodos addforeignKeys e addUniqueKeys da classe ancestral são chamados para adicionar as chaves estrangeiras e chaves únicas, respectivamente.
	 
	 * Deve-se utilizar as anotações
	 *@DBSchema,
	 *@DBTable,
	 *@DBField,
	 *@DBPrimaryKey,
	 *@DBForeignKey,
	 *@DBNotNull,
	 *@DBUniqueKey.
	 *
	 *Exemplo:
	 
	 ```php
	 
	 /**
	 @DBSchema("kukafit")
	 @DBTable("usuarios")
	 * /
	 class Usuarios {
	    /**
    	 @DBField("idUsuario")
    	 @DBPrimaryKey
    	 @DBNotNull
    	 @DBUniqueKey
    	 //
    	private$idUsuario;
    	
    	/**
    	 @DBField("nome")
    	 @DBNotNull
    	* /
    	private$nome;
    	
    	/**
    	 @DBField("dtNasc")
    	 @DBNotNull
    	* /
    	private$dtNasc;
    	
    	/**
    	 @DBField("cpf")
    	 @DBUniqueKey
    	* /
    	private$cpf;
    	
    	/**
    	 @DBField("escolaridade")
    	 @DBForeignKey("idNivelEscolar", "nivelEscolar", "idNivelEscolar")
    	* /
    	private$escolaridade;
    	
    	/**
    	 @DBField("email")
    	 @DBNotNull
    	 @DBUniqueKey
    	* /
    	private$email;
    	
    	/**
    	 @DBField("senha")
    	 @DBNotNull
    	* /
    	private$senha;
	}
	 ```
*/
}


?>


        <?php

namespace core\database;

use core\utils\Sanitize;
use Exception;
use InvalidArgumentException;
use PDOException;

/**
 * Classe DBQuery
 *
 * Esta classe representa uma consulta ao banco de dados.
 *
 * @package app\core\database
 */
class DBQuery {
    
    /**
     * @var object $conn A conexão com o banco de dados
     */
    private $conn;
    
    /**
     * @var string $tableName O nome da tabela
     */
    private $tableName;
    
    /**
     * @var array $fieldsName Os nomes dos campos da tabela
     */
    private $fieldsName;
    
    /**
     * @var array $primaryKeys As chaves primárias da tabela
     */
    private $primaryKeys = [];
    
    /**
     * @var array $foreignKeys As chaves estrangeiras da tabela
     */
    private $foreignKeys = [];
    
    /**
     * @var array $uniqueKeys As chaves únicas da tabela
     */
    private $uniqueKeys = [];
    
    /**
     * @var array $joins As cláusulas JOIN da consulta
     */
    private $joins = [];
    
    /**
     * @var array $outerJoins As cláusulas OUTER JOIN da consulta
     */
    private $outerJoins = [];
    
    /**
     * Construtor da classe DBQuery
     *
     * @param string $tableName O nome da tabela
     * @param string $fieldsNames Os nomes dos campos da tabela separados por vírgula
     * @param mixed $primaryKeys As chaves primárias da tabela (pode ser uma string ou um array)
     */
    public function __construct($tableName, $fieldsNames, $primaryKeys) {
        $this->tableName = $tableName;
        $this->fieldsName = explode(',', $fieldsNames);
        for ($i = 0; $i < count($this->fieldsName); $i++) {
            $this->fieldsName[$i] = trim($this->fieldsName[$i]);
        }
        $this->primaryKeys = is_array($primaryKeys) ? $primaryKeys : [$primaryKeys];
        $this->conn = (new DBConnection())->getConn();
    }
    
    /**
     * Adiciona uma cláusula JOIN à consulta
     *
     * @param string $type O tipo de junção (INNER, LEFT, RIGHT, FULL, CROSS)
     * @param string $fieldname O nome do campo da tabela atual usado na junção
     * @param DBQuery $dbQueryJoined A consulta à tabela que será unida
     * @param string $fieldNameJoined O nome do campo da tabela unida usado na junção
     * @throws InvalidArgumentException Se o tipo de junção for inválido
     * @return void
     */
    public function addJoin($type, $fieldname, DBQuery $dbQueryJoined, $fieldNameJoined) {
        if (!in_array($type, ["INNER","LEFT","RIGHT","FULL","CROSS"])) {
            throw new InvalidArgumentException("Tipo de junção inválido: $type");
        }
        $this->joins[] = $type . " JOIN " . $dbQueryJoined->getTableName() . " ON " . $this->tableName . "." . $fieldname . " = " . $dbQueryJoined->getTableName() . "." . $fieldNameJoined;
    }
    
    /**
     * Adiciona uma cláusula OUTER JOIN à consulta
     *
     * @param string $type O tipo de junção externa (LEFT, RIGHT, FULL)
     * @param string $fieldname O nome do campo da tabela atual usado na junção
     * @param DBQuery $dbQueryJoined A consulta à tabela que será unida
     * @param string $fieldNameJoined O nome do campo da tabela unida usado na junção
     * @throws InvalidArgumentException Se o tipo de junção externa for inválido
     * @return void
     */
    public function addOuterJoin($type, $fieldname, DBQuery $dbQueryJoined, $fieldNameJoined) {
        if (!in_array($type, ["LEFT","RIGHT","FULL"])) {
            throw new InvalidArgumentException("Tipo de junção externa inválido: $type");
        }
        $this->outerJoins[] = $type . " OUTER JOIN " . $dbQueryJoined->getTableName() . " ON " . $this->tableName . "." . $fieldname . " = " . $dbQueryJoined->getTableName() . "." . $fieldNameJoined;
    }
    
    /**
     * Adiciona chaves únicas à tabela
     *
     * @param array $uniqueKeys As chaves únicas a serem adicionadas
     * @return void
     */
    public function addUniqueKeys($uniqueKeys) {
        $this->uniqueKeys[] = $uniqueKeys;
    }
    
    /**
     * Adiciona chaves estrangeiras à tabela
     *
     * @param string $field O campo da tabela atual usado como chave estrangeira
     * @param string $referenceTable A tabela de referência para a chave estrangeira
     * @param string $referenceField O campo de referência para a chave estrangeira
     * @return void
     */
    public function addForeignKeys($field, $referenceTable, $referenceField) {
        $this->foreignKeys[] = ['field' => $field, 'referenceTable' => $referenceTable, 'referenceField' => $referenceField];
    }
    
    /**
     * Executa uma consulta SELECT sem filtros
     *
     * @return mixed O resultado da consulta
     */
    public function select() {
        $fields = implode(', ', $this->fieldsName);
        $sql = "SELECT {$fields} FROM {$this->tableName}";
        return $this->conn->query($sql);
    }
  
    public function selectWhere($where) {
        $fields = implode(', ', $this->fieldsName);
        $sql = "SELECT {$fields} FROM {$this->tableName}" . (($where!="")?$where:"");
        return $this->conn->query($sql);
    }
    
    /**
     * Executa uma consulta SELECT com filtros
     *
     * @param Where $where O objeto Where contendo as condições de filtro
     * @return mixed O resultado da consulta
     */
    public function selectFiltered(Where $where) {
        $fields = implode(', ', $this->fieldsName);
        $sql = "SELECT {$fields} FROM {$this->tableName}";
        foreach ($this->joins as $join) {
            $sql .= " " . $join;
        }
        foreach ($this->outerJoins as $outerJoin) {
            $sql .= " " . $outerJoin;
        }
        $sql .= $where->build();
        return $this->conn->query($sql);
    }
    
    /**
     * Executa uma consulta de inserção de dados na tabela
     *
     * @param array $values Os valores a serem inseridos na tabela
     * @throws InvalidArgumentException Se o número de valores não for equivalente aos campos da tabela
     * @throws Exception Se ocorrer uma violação de chave única ou estrangeira
     * @return mixed O resultado da consulta
     */
    public function insert($values) {
        //$values = (new Sanitize(false, false, true))->toClean($values);
        
        if (count($values) !== count($this->fieldsName)) {
            throw new InvalidArgumentException("O número de valores informados não é equivalente aos campos da tabela!");
        }
        
        $sql = "INSERT INTO {$this->tableName} (" . implode(', ', $this->fieldsName) . ")";
        $sql .= " VALUES ('" . implode("', '", $values) . "')";
        try {
            return $this->conn->query($sql);
        } catch ( PDOException $error) {
            if ($error->getCode() == 23000) {
                throw new \Exception('Violação de chave única ou estrangeira.');
            }
            throw $error;
        }
    }
    
    /**
     * Executa uma consulta de atualização de dados na tabela
     *
     * @param array $values Os novos valores dos campos a serem atualizados
     * @throws InvalidArgumentException Se a quantidade de campos for diferente da quantidade de valores
     * @throws Exception Se ocorrer uma violação de chave única ou estrangeira
     * @return mixed O resultado da consulta
     */
    public function update($values) {
        $values = (new Sanitize(false, false, true))->toClean($values);
        
        if (count($values) !== count($this->fieldsName)) {
            throw new InvalidArgumentException("A quantidade de campos é diferente da quantidade de valores!");
        }
        
        $sql = "UPDATE {$this->tableName} SET ";
        
        for ($i = 0; $i < count($values); $i++) {
            $sql .= "{$this->fieldsName[$i]} = '{$values[$i]}'";
            if ($i !== count($values) - 1) {
                $sql .= ", ";
            }
        }
        
        $where = new Where();
        // Construir a cláusula WHERE com base nas chaves primárias
        foreach ($this->primaryKeys as $primaryKey) {
            $position = array_search($primaryKey, $this->fieldsName);
            if ($position !== false && isset($values[$position])) {
                $where->addCondition("AND", $primaryKey, "=", $values[$position]);
            } else {
                throw new InvalidArgumentException("Valor da chave primária não encontrado: $primaryKey");
            }
        }
        $sql .= $where->build();
        
        try {
            return $this->conn->query($sql);
        } catch ( PDOException $error) {
            if ($error->getCode() == 23000) {
                throw new Exception('Violação de chave única ou estrangeira.');
            }
            throw $error;
        }
    }
    
    /**
     * Atualiza os valores validados na tabela.
     *
     * @param array $values Os valores a serem atualizados
     * @return bool Retorna true se a atualização for bem-sucedida, caso contrário, lança uma exceção
     * @throws InvalidArgumentException Se a quantidade de campos for diferente da quantidade de valores, algum valor da chave primária não for encontrado, ou ocorrer violação de chave única ou estrangeira
     * @throws Exception Se ocorrer qualquer outra exceção do PDO
     */
    public function updateValidated($values) {
        $values = (new Sanitize(false, false, true))->toClean($values);
        
        if (count($values) !== count($this->fieldsName)) {
            throw new InvalidArgumentException("A quantidade de campos é diferente da quantidade de valores!");
        }
        
        // Verificar campos não nulos
        foreach ($this->notNullFields as $field) {
            $position = array_search($field, $this->fieldsName);
            if ($position !== false && empty($values[$position])) {
                throw new InvalidArgumentException("O campo '{$field}' não pode ser nulo!");
            }
        }
        
        // Verificar chaves únicas
       /*  foreach ($this->uniqueKeys as $uniqueKey) {
            $position = array_search($uniqueKey, $this->fieldsName);
            if ($position !== false && isset($values[$position])) {
                $where = new Where();
                $where->addCondition("AND", $uniqueKey, "=", $values[$position]);
                
                // Excluir a condição das chaves primárias para evitar falsos positivos
                foreach ($this->primaryKeys as $primaryKey) {
                    $where->addCondition("AND", $primaryKey, "!=", $values[$position]);
                }
                
                $sql = "SELECT COUNT(*) FROM {$this->tableName} " . $where->build();
                $count = $this->conn->query($sql)->fetchColumn();
                
                if ($count > 0) {
                    throw new InvalidArgumentException("Já existe um registro com o valor '{$values[$position]}' para o campo '{$uniqueKey}'!");
                }
            }
        } */
        
        // Verificar chaves estrangeiras
        /* foreach ($this->foreignKeys as $foreignKey) {
            $column = $foreignKey['column'];
            $refTable = $foreignKey['refTable'];
            $refColumn = $foreignKey['refColumn'];
            $position = array_search($column, $this->fieldsName);
            
            if ($position !== false && isset($values[$position])) {
                $where = new Where();
                $where->addCondition("AND", $refColumn, "=", $values[$position]);
                $sql = "SELECT COUNT(*) FROM {$refTable} " . $where->build();
                $count = $this->conn->query($sql)->fetchColumn();
                
                if ($count === 0) {
                    throw new InvalidArgumentException("O valor '{$values[$position]}' para o campo '{$column}' não existe na tabela de referência '{$refTable}'!");
                }
            }
        } */
        
        $sql = "UPDATE {$this->tableName} SET ";
        
        for ($i = 0; $i < count($values); $i++) {
            $sql .= "{$this->fieldsName[$i]} = '{$values[$i]}'";
            if ($i !== count($values) - 1) {
                $sql .= ", ";
            }
        }
        
        $where = new Where();
        // Construir a cláusula WHERE com base nas chaves primárias
        foreach ($this->primaryKeys as $primaryKey) {
            $position = array_search($primaryKey, $this->fieldsName);
            if ($position !== false && isset($values[$position])) {
                $where->addCondition("AND", $primaryKey, "=", $values[$position]);
            } else {
                throw new InvalidArgumentException("Valor da chave primária não encontrado: $primaryKey");
            }
        }
        $sql .= $where->build();
        
        try {
            return $this->conn->query($sql);
        } catch (PDOException $error) {
            if ($error->getCode() == 23000) {
                throw new Exception('Violação de chave única ou estrangeira.');
            }
            throw $error;
        }
    }
    
    
    /**
     * Executa uma consulta de exclusão de dados na tabela
     *
     * @throws InvalidArgumentException Se ocorrer uma violação de chave única ou estrangeira
     * @return mixed O resultado da consulta
     */
    public function delete($values) {
        $sql = "DELETE FROM {$this->tableName}";
        
        $where = new Where();
        // Construir a cláusula WHERE com base nas chaves primárias
        foreach ($this->primaryKeys as $primaryKey) {
            $position = array_search($primaryKey, $this->fieldsName);
            if ($position !== false && isset($values[$position])) {
                $where->addCondition("AND", $primaryKey, "=", $values[$position]);
            } else {
                throw new InvalidArgumentException("Valor da chave primária não encontrado: $primaryKey");
            }
        }
        $sql .= $where->build();
        
        try {
            return $this->conn->query($sql);
        } catch ( PDOException $error) {
            if ($error->getCode() == 23000) {
                throw new Exception('Não é possível excluir esta linha porque existem dados dependentes.');
            }
            throw $error;
        }
    }
    
    /**
     * Obtém a conexão com o banco de dados
     *
     * @return object A conexão com o banco de dados
     */
    public function getConn() {
        return $this->conn;
    }
    
    /**
     * Define a conexão com o banco de dados
     *
     * @param object $conn A conexão com o banco de dados
     * @return void
     */
    public function setConn($conn) {
        $this->conn = $conn;
    }
    
    /**
     * Obtém o nome da tabela
     *
     * @return string O nome da tabela
     */
    public function getTableName() {
        return $this->tableName;
    }
    
    /**
     * Define o nome da tabela
     *
     * @param string $tableName O nome da tabela
     * @return void
     */
    public function setTableName($tableName) {
        $this->tableName = $tableName;
    }
    
    /**
     * Obtém os nomes dos campos da tabela
     *
     * @return array Os nomes dos campos da tabela
     */
    public function getFieldsName() {
        return $this->fieldsName;
    }
    
    /**
     * Define os nomes dos campos da tabela
     *
     * @param string $fieldsName Os nomes dos campos da tabela separados por vírgula
     * @return void
     */
    public function setFieldsName($fieldsName) {
        $this->fieldsName = explode(',', $fieldsName);
        for ($i = 0; $i < count($this->fieldsName); $i++) {
            $this->fieldsName[$i] = trim($this->fieldsName[$i]);
        }
    }
    
    /**
     * Obtém as chaves primárias da tabela
     *
     * @return array As chaves primárias da tabela
     */
    public function getPrimaryKeys() {
        return $this->primaryKeys;
    }
    
    /**
     * Define as chaves primárias da tabela
     *
     * @param array $primaryKeys As chaves primárias da tabela
     * @return void
     */
    public function setPrimaryKeys($primaryKeys) {
        $this->primaryKeys = $primaryKeys;
    }
    
    /**
     * Obtém as chaves estrangeiras da tabela
     *
     * @return array As chaves estrangeiras da tabela
     */
    public function getForeignKeys() {
        return $this->foreignKeys;
    }
    
    /**
     * Define as chaves estrangeiras da tabela
     *
     * @param array $foreignKeys As chaves estrangeiras da tabela
     * @return void
     */
    public function setForeignKeys($foreignKeys) {
        $this->foreignKeys = $foreignKeys;
    }
    
    /**
     * Obtém as chaves únicas da tabela
     *
     * @return array As chaves únicas da tabela
     */
    public function getUniqueKeys() {
        return $this->uniqueKeys;
    }
    
    /**
     * Define as chaves únicas da tabela
     *
     * @param array $uniqueKeys As chaves únicas da tabela
     * @return void
     */
    public function setUniqueKeys($uniqueKeys) {
        $this->uniqueKeys = $uniqueKeys;
    }
}
?>
<?php

namespace core\database;

use core\utils\Sanitize;

/**
 * Classe Where
 *
 * Essa classe é responsável por gerar cláusulas WHERE em SQL.
 *
 * Exemplo de uso:
 *
 * ```php
 * $where = new Where();
 * $where->addCondition('AND', 'nome', '=', 'João');
 * $where->addCondition('OR', 'idade', '>', 30);
 * $query = $where->build();
 * echo $query; // Produz: WHERE nome = ? AND idade > ?
 * ```
 */
class Where {
    
    private $conditions = array();
    
    public function __construct(){
        
    }
    
    /**
     * Adiciona uma condição à cláusula WHERE.
     *
     * @param string $logicOperator O operador lógico para a condição (AND, OR).
     * @param string $fieldName O nome do campo para a condição.
     * @param string $operator O operador para a condição (por exemplo, =, <, >, LIKE, etc.).
     * @param mixed $value O valor a ser comparado na condição.
     *
     */
    public function addCondition($logicOperator, $fieldName, $operator, $value) {
        // $value = (new Sanitize(false, false, true))->toClean($value);
        $this->conditions[] = array(
            "logicOperator" => $logicOperator,
            "fieldName" => $fieldName,
            "operator" => $operator,
            "value" => $value
        );
    }
    
    /**
     * Adiciona uma condição LIKE à cláusula WHERE.
     *
     * @param string $logicOperator O operador lógico para a condição (AND, OR).
     * @param string $fieldName O nome do campo para a condição.
     * @param mixed $value O valor a ser comparado na condição.
     *
     */
    public function addLike($logicOperator, $fieldName, $value) {
        $value = (new Sanitize())->toClean($value);
        $this->conditions[] = array(
            "logicOperator" => $logicOperator,
            "operator" => "LIKE",
            "fieldName" => $fieldName,
            "value" => "%".$value."%"
        );
    }
    
    /**
     * Adiciona uma condição NOT LIKE à cláusula WHERE.
     *
     * @param string $logicOperator O operador lógico para a condição (AND, OR).
     * @param string $fieldName O nome do campo para a condição.
     * @param mixed $value O valor a ser comparado na condição.
     *
     */
    public function addNotLike($logicOperator, $fieldName, $value) {
        $value = (new Sanitize())->toClean($value);
        $this->conditions[] = array(
            "logicOperator" => $logicOperator,
            "operator" => "NOT LIKE",
            "fieldName" => $fieldName,
            "value" => "%".$value."%"
        );
    }
    
    /**
     * Adiciona uma condição IN à cláusula WHERE.
     *
     * @param string $logicOperator O operador lógico para a condição (AND, OR).
     * @param string $fieldName O nome do campo para a condição.
     * @param mixed $values Os valores a serem comparados na condição (deve ser um array).
     *
     */
    public function addIn($logicOperator, $fieldName, $values) {
        $values = (new Sanitize())->toClean($values);
        $this->conditions[] = array(
            "logicOperator" => $logicOperator,
            "operator" => "IN",
            "fieldName" => $fieldName,
            "value" => $values
        );
    }
    
    /**
     * Adiciona uma condição NOT IN à cláusula WHERE.
     *
     * @param string $logicOperator O operador lógico para a condição (AND, OR).
     * @param string $fieldName O nome do campo para a condição.
     * @param mixed $values Os valores a serem comparados na condição (deve ser um array).
     *
     */
    public function addNotIn($logicOperator, $fieldName, $values) {
        $values = (new Sanitize(false, false, true))->toClean($values);
        $this->conditions[] = array(
            "logicOperator" => $logicOperator,
            "operator" => "NOT IN",
            "fieldName" => $fieldName,
            "value" => $values
        );
        return $this;
    }
    
    /**
     * Adiciona uma condição BETWEEN à cláusula WHERE.
     *
     * @param string $logicOperator O operador lógico para a condição (AND, OR).
     * @param string $fieldName O nome do campo para a condição.
     * @param mixed $min O valor mínimo a ser comparado na condição.
     * @param mixed $max O valor máximo a ser comparado na condição.
     *
     */
    public function addBetween($logicOperator, $fieldName, $min, $max) {
        $min = (new Sanitize(false, false, true))->toClean($min);
        $max = (new Sanitize(false, false, true))->toClean($max);
        $this->conditions[] = array(
            "logicOperator" => $logicOperator,
            "operator" => "BETWEEN",
            "fieldName" => $fieldName,
            "value" => array($min, $max)
        );
    }
    
    /**
     * Adiciona uma condição NOT BETWEEN à cláusula WHERE.
     *
     * @param string $logicOperator O operador lógico para a condição (AND, OR).
     * @param string $fieldName O nome do campo para a condição.
     * @param mixed $min O valor mínimo a ser comparado na condição.
     * @param mixed $max O valor máximo a ser comparado na condição.
     */
    public function addNotBetween($logicOperator, $fieldName, $min, $max) {
        $min = (new Sanitize())->toClean($min);
        $max = (new Sanitize())->toClean($max);
        $this->conditions[] = array(
            "logicOperator" => $logicOperator,
            "operator" => "NOT BETWEEN",
            "fieldName" => $fieldName,
            "value" => array($min, $max)
        );
    }
    
    /**
     * Retorna as condições armazenadas.
     *
     * @return array As condições armazenadas.
     */
    public function getConditions() {
        return $this->conditions;
    }
    
    /**
     * Limpa todas as condições armazenadas.
     */
    public function clearConditions() {
        $this->conditions = array();
    }
    
    /**
     * Constrói a cláusula WHERE com base nas condições armazenadas.
     *
     * @return string $whereClause cláusula WHERE construída.
     */
    public function build() {
        $whereClause = "";
        $hasConditions = false;
        
        foreach ($this->conditions as $condition) {
            if (!empty($condition["value"])) {
                if ($hasConditions) {
                    $whereClause .= " " . $condition["logicOperator"] . " ";
                }
                else {
                    $whereClause .= " WHERE ";
                    $hasConditions = true;
                }
                $fieldName = $condition["fieldName"];
                $operator = $condition["operator"];
                $value = $condition["value"];
                
                switch ($operator) {
                    case "IN":
                    case "NOT IN":
                        $value = implode(",", $value);
                        $whereClause .= $fieldName . " " . $operator . " (" . $value . ")";
                        break;
                    case "BETWEEN":
                    case "NOT BETWEEN":
                        $whereClause .= $fieldName . " " . $operator . " " . $value[0] . " AND " . $value[1];
                        break;
                    case "LIKE":
                    case "NOT LIKE":
                        $whereClause .= $fieldName . " " . $operator . " '" . $value . "'";
                        break;
                    default:
                        $whereClause .= $fieldName . " " . $operator  . " '" . $value . "'";
                        break;
                }
            }
        }
        return ( $whereClause );
    }
}

/**
  *   Exemplos de uso da classe Where
  *   
  *   Instanciando a classe
  *   $where = new Where();
  *   
  *   addCondition
  *   Exemplo: SELECT  *   FROM tabela WHERE campo = 'valor'
  *   $where->addCondition('AND', 'campo', '=', 'valor');
  *   
  *   addLike
  *   Exemplo: SELECT  *   FROM tabela WHERE campo LIKE '%valor%'
  *   $where->addLike('AND', 'campo', 'valor');
  *   
  *   addNotLike
  *   Exemplo: SELECT  *   FROM tabela WHERE campo NOT LIKE '%valor%'
  *   $where->addNotLike('AND', 'campo', 'valor');
  *   
  *   addIn
  *   Exemplo: SELECT  *   FROM tabela WHERE campo IN ('valor1', 'valor2')
  *   $where->addIn('AND', 'campo', ['valor1', 'valor2']);
  *  
  *   addNotIn
  *   Exemplo: SELECT  *   FROM tabela WHERE campo NOT IN ('valor1', 'valor2')
  *   $where->addNotIn('AND', 'campo', ['valor1', 'valor2']);
  *   
  *   addBetween
  *   Exemplo: SELECT  *   FROM tabela WHERE campo BETWEEN 'valor1' AND 'valor2'
  *   $where->addBetween('AND', 'campo', 'valor1', 'valor2');
  *  
  *   addNotBetween
  *   Exemplo: SELECT  *   FROM tabela WHERE campo NOT BETWEEN 'valor1' AND 'valor2'
  *   $where->addNotBetween('OR', 'campo', 'valor1', 'valor2');
  *   
  *   build
  *   Cria a cláusula WHERE baseada nas condições adicionadas
  *   $whereClause = $where->build();
  *   
  *   getConditions
  *   Retorna as condições adicionadas
  *   $conditions = $where->getConditions();
  *   
  *   clearConditions
  *   Limpa todas as condições adicionadas
  *   $where->clearConditions();
*/

?>
